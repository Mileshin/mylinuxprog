Введение
========

Эта практикум является конспектом курса практических занятий по
написанию кодов ядра Linux. Занятия организовывались компанией Global
Logic ([http://www.globallogic.com/](http://www.globallogic.com/)) для
сотрудников (программистов-разработчиков) украинских отделений
([http://globallogic.com.ua](http://globallogic.com.ua/)) компании. Этот
курс практических занятий основывается на моих же материалах проводимых
ранее тренингов «Программирование модулей ядра Linux», текст и примеры
кодов которых можно найти, например, здесь:
[http://mylinuxprog.blogspot.com/2015/01/linux.html](http://mylinuxprog.blogspot.com/2015/01/linux.html).
Зачем, при наличии этих предыдущих текстов, готовить новый материал, в
чём отличия? Отличия в том, что:

-   Данный курс рассчитан на слушателей, которые **уже имеют начальные
    навыки** программирования для ядра Linux, и их целью является только
    совершенствование в этом предмете.

-   Основной целью является не показ иллюстрирующих кодов, а
    формулирование задач для самостоятельной проработки, и последующее
    обсуждение их решений

*Материалы данной книги (сам текст, сопутствующие его примеры, файлы
содержащие эти примеры), как и предмет её рассмотрения — задумывались и
являются свободно распространяемыми.**На них автором накладываются
условия свободной лицензии
(**[http://legalfoto.ru/licenzii/](http://legalfoto.ru/licenzii/)**)****Creative
Commons Attribution ShareAlike****: допускается копирование,
коммерческое использование произведения, создание его производных при
чётком указании источника, но при том единственном ограничении, что при
использовании или переработке разрешается применять результат****только
на условиях аналогичной лицензии****.*

Требуемый начальный уровень
---------------------------

Курс рассчитана на **опытных** разработчиков системного программного
обеспечения. Предполагается некоторый минимальный опыт в
программировании для ядра Linux (модули, драйвера), на уровне
компиляции, сборки, и использования таких модулей в системе.

Совершенно естественно, что от читателя требуется квалифицированное
знание языка C — единственного необходимого и достаточного языка
системного программирования (из числа компилирующих) в Linux (хоть в
пространстве ядра, хоть в пользовательском пространстве).

Естественно, я предполагаю, что вы «на дружеской ноге» с основными
UNIX/POSIX консольными утилитами, такими, как: ls, rm, grep, tar и
другие. Это необходимо для тестирования и организации работы с
проектируемыми компонентами. В Linux используются, наибольшим образом,
GNU (FSF) реализации таких утилит, которые набором опций часто
отличаются (чаще в сторону расширения) от предписаний стандарта POSIX, и
отличаются, порой, от своих собратьев в других операционных системах
(Solaris, QNX, ...). Но эти отличия не столь значительны, я думаю, чтобы
вызвать какие-либо затруднения.

Последовательность изложения
----------------------------

Представленный порядок тем (глав) вызывал несколько раз обсуждения и
возражения: сначала обсуждается общая структура драйверов устройств и
сетевого стека, а только затем — реализация внутренних механизмов ядра,
используемые в коде этих драйверов.

Прежде всего, любой раздел из области программирования не описывается в
линейном изложении, и требует рекурсивного изложения, когда приходится
оперировать терминами и понятиями, которые будут определены только
позже. Это хорошо известно из теории языков программирования.

Во-вторых, автор предпочитает рассмотрение сверху-вниз альтернативному
снизу-вверх, что также много обсуждалось в теории программирования и не
нуждается в разъяснениях.

Далее, представленный материал, как было сказано, ориентирован на
достаточно опытного практика, которому встречаемые ним механизмы низкого
уровня будут интуитивно понятны и без дополнительных объяснений, хотя бы
по аналогиям из POSIX, которым они достаточно близки.

И, наконец, самое главное: целевая направленность текста на
сопровождение упражнений и задач для самостоятельной проработки
слушателей. А без возможности создания работающих и тестируемых модулей
невозможно написание кода, отрабатывающего какой-то из механизмов. Таким
образом, прежде рассмотрения общей структуры программ модулей, любое
детальное описание механизмов становится голословным рассказом.

Если некоторые термины и механизмы ядра, используемые в примерах,
покажутся вам совершенно незнакомыми, рассмотрите их забежав вперёд, в
части, касающейся обсуждения внутренних программных механизмов ядра.

Каждый раздел завершается формулировками нескольких задач относительно
материала раздела. Задачами они названы достаточно условно, диапазон их
широк: от относительно несложных **вопросов**, до **задач**, требующих
создания законченных мини-проектов. Но даже вопросы, которые кажутся
элементарными, отбирались из числа тех, которые «с подковыркой», и
требуют обстоятельного **понимания** материала. Задачи, естественно,
предназначены для самостоятельной проработки. На них не даются ответы в
тексте. Но по всем задачам, требующих написания программного кода (а
таких подавляющее большинство), показаны варианты решения «от автора» в
архиве примеров, сопровождающем текст.

Соглашения принятые в тексте
----------------------------

Этот текст ориентировался, в первую очередь, не столько для чтения или
подробных разъяснений, сколько в качестве справочника при решении
практических задач. Это накладывает отпечаток на текст:

-   Перечисления альтернатив, например, символьных констант для
    выражения значений некоторого параметра, в случае их
    многочисленности приводится **не полностью** — разъясняются только
    наиболее употребимые, акцент делается на понимании (всё остальное
    может быть найдено в заголовочных файлах ядра — вместо путанного
    перечисления 30-ти альтернатив лучше указать две, использующиеся в
    95% случаев).

-   Обязательно указываются те места для поиска (имена заголовочных
    файлов, файлы описаний) где можно (попытаться) разыскать ту же
    информацию, но актуальную в требуемой вами версии ядра; это связано
    с постоянными изменениями, происходящими от версии к версии.

-   Обсуждаемые задачи — примеры законченные, исполнимые и проверенные.
    Примеры оформлены как небольшие проекты, которые собираются
    достаточно тривиально (многие проекты содержат файл \*.hist — это
    протокол с терминала тех действий, которые выполнялись по сборке и
    тестированию данного проекта, это многое разъясняет: зачем сделан
    этот пример и что он должен показать).

Для ясности чтения текста, он размечен шрифтами по функциональному
назначению, в принципе, такая разметка уже употребляется практически
повсеместно. Для выделения фрагментов текста по назначению используется
разметка:

-   Некоторые ключевые понятия и термины в тексте, на которые нужно
    обратить особое внимание, будут выделены **жирным шрифтом**.

-   Таким же моноширинным шрифтом (прямо в тексте) будут выделяться
    написание: имён команд, программ, файлов ... — всех тех терминов,
    которые должны оставаться неизменяемыми, например: /proc, mkdir,
    ./myprog, ...

-   Ввод пользователя в консольных командах (сами выполняемые команды,
    или ответы в диалоге), кроме того, выделены **жирным моноширинным
    шрифтом**, чтобы отличать их от ответного вывода системы в диалогах.

-   Имена файлов программных листингов (как они придаются в архиве
    примеров) записаны 1-й строкой, предшествующей листингу, и выделены
    ***жирным подчёркнутым курсивом***.

В показанных примерах команд изображение символа приглашения, без
дополнительных напоминаний, будет показывать уровень прав, которые
требует данная команда: \# - будет означать команду с правами root, \$ -
команду в правами ординарного пользователя.

В задачах, перечисляемых после каждого раздела, некоторые из них
отмечены знаком (\*). Так отмечены задачи, как это часто и принято,
повышенной сложности. Это не задачи, требующие большой трудоёмкости для
своего решения (а таких немало), а требующие нестандартных решений и
находок, выходящих за рамки материала, освещаемого в тексте.

Код примеров и замеченные опечатки
----------------------------------

Все листинги, приводимые в качестве примеров, были опробованы и
испытаны. Архивы (вида \*.tgz), содержащие листинги, представлены на
едином общедоступном ресурсе, там же, где и сам текст рукописи. В
тексте, где обсуждаются коды примеров, везде, по возможности, будет
указано в скобках имя архива в этом источнике, например: (архив
export.tgz, или это может быть каталог export). В зависимости от того, в
каком виде (свёрнутом или развёрнутом) вам достались файлы примеров, то,
что названо по тексту «архив», может быть представлен на самом деле
каталогом, содержащим файлы этого примера, поэтому, относительно
«целеуказания» примеров, термины **архив** и **каталог** будут
употребляться как синонимы. Один и тот же архив может упоминаться
несколько раз в самых разных главах описания — это не ошибка: в одной
теме он может иллюстрировать структуру, в другой — конкретные механизмы
ввода/вывода, в третьей — связывание внешних имён объектных файлов и так
далее. Листинги, поэтому, специально не нумерованы (нумерация могла бы
«сползти» при правках), но указаны архивы, где их можно найти в полном
виде. В архивах примеров **могут** содержаться файлы вида \*.hist
(расширение от history) — это текстовые файлы протоколов выполнения
примеров: порядок запуска приложений, и какие результаты следует
ожидать, и на что обратить внимание..., в тех случаях, когда сборка
(make) примеров требует каких-то специальных приёмов, протокол сборки
также может быть тоже показан в этом файле.

И ещё одно немаловажное замечание относительно программных кодов. Я
отлаживал и проверял эти примеры на не менее полтора десятка различных
инсталляций Linux (реальных и виртуальных, 32 и 64 разрядные
архитектуры, установленных из различных дистрибутивов, и разных семейств
дистрибутивов: Fedora, CentOS, Debian, Ubuntu, ...). И в некоторых
случаях **давно работающий** пример перестаёт компилироваться с
совершенно дикими сообщениями вида:

/home/olej/Kexamples.BOOK/IRQ/mod\_workqueue.c:27:3: ошибка: неявная
декларация функции ‘kfree’

/home/olej/Kexamples.BOOK/IRQ/mod\_workqueue.c:37:7: ошибка: неявная
декларация функции ‘kmalloc’

Пусть вас это не смущает! В разных инсталляциях может нарушаться порядок
взаимных ссылок заголовочных файлов, и какой-то из заголовочных файлов
выпадает из определений. В таких случаях вам остаётся только разыскать
недостающий файл (а по тексту для всех групп API я указываю файлы их
определений), и включить его явным указанием. Вот, например, показанные
выше сообщения об ошибках устраняются включением строки:

\#include \<linux/slab.h\>

Но такое же включение для других инсталляций (дистрибутивов и версий)
будет избыточным (но не навредит).

Конечно, при самой тщательной выверке и вычитке, не исключены недосмотры
и опечатки в таком объёмном тексте, могут проскочить мало внятные
стилистические обороты и подобное. О замеченных таких дефектах я прошу
сообщать по электронной почте [olej@front.ru](mailto:olej@front.ru), и я
был бы признателен за любые указанные недостатки книги, замеченные
ошибки, или высказанные пожелания по её доработке.

Замечания о дистрибутивах и версиях ядра
----------------------------------------

Этот текст, в нынешнем его виде, накапливался, подготавливался, писался,
изменялся и дополнялся на протяжении достаточно продолжительного времени
(более 3-х лет). К нему отбирались, писались, отрабатывались и
совершенствовались примеры реализации кода. За всё это время «в обиходе»
сменились версии ядра от 2.6.32 до 3.17 (на момент написания). Примеры и
команды, показываемые в тексте, отрабатывались и проверялись на всём
этом диапазоне, и, в дополнение, на нескольких различных дистрибутивах
Linux: Fedora, CentOS, Debian, Ubuntu. Помимо этого, в качестве основы
для некоторых примеров брался код из реальных проектов автора прошлых
лет ещё в системе CentOS 5.2 (для проверки переносимости, стабильности):

\$ uname -r

2.6.18-92.el5

Кроме того, разнообразие вносит и то, что примеры отрабатывались: а). на
32-бит и 64-бит инсталляциях и б). на реальных инсталляциях и нескольких
виртуальных машинах под управлением Oracle VirtualBox. Как легко видеть,
для проверок и сравнений были использованы варианты по возможности
широкого спектра различий. Хотя выверить **все** примеры и на **всех**
вариантах установки — это за гранью человеческих возможностей. Ещё на
иных дистрибутивах Linux могут быть какие-то отличия, особенно в путевых
именах файлов, но они не должны быть особо существенными.

К версии (ядра) нужно подходить с очень большой осторожностью: ядро —
это не пользовательский уровень, и разработчики не особенно обременяют
себя ограничениями совместимости снизу вверх (в отличие от
пользовательских API, POSIX). Источники информации и обсуждения, в
множестве разбросанные по Интернет, чаще всего относятся к устаревшим
версиям ядра, и абсолютно не соответствуют текущему положению дел. Очень
показательно это проявилось, например, в отношении макросов подсчёта
ссылок использования модулей, которые до версий 2.4.Х использовались:
MOD\_INC\_USE\_COUNT и MOD\_DEC\_USE\_COUNT, но их нет в 2.6.Х и далее,
но они продолжают фигурировать во множестве описаний.

Использованные источники информации
-----------------------------------

Литература по программированию модулей ядра Linux хоть и малочисленна,
но она есть. В конце книги приведено достаточно много обстоятельных
источников информации по этому предмету. Основные использовавшиеся
источники информации (которые показались мне самыми полезными)
перечислены в конце текста, в разделе «Источники информации». В
некоторых случаях это только указание выходных данных книг. Там где
существуют изданные русскоязычные их переводы — я старался указать и
переводы тоже. По некоторым источникам, авторы которых решили сделать их
публично доступными, показаны ссылки на них в сети. Для статей, которые
взяты из сети, я указываю URL и, по возможности, авторов публикации, но
далеко не по всем материалам, разбросанным и кочующим по Интернет,
удаётся установить их авторство.

**1.****Специфика программирования в ядре**
===========================================

Программирование в ядре имеет определённые отличия от программирования
пользовательских приложений и накладывает определённые сложности и
ограничения. И прежде чем переходить к конкретике программирования в
ядре, разумно изучить те сложности, которые будут подстерегать и
подготовиться к ним.

Различия в техниках программирования
------------------------------------

​1. В ядре **недоступны никакие библиотеки**, привычные из прикладного
программирования, и известные как POSIX API. Причин на то много, и их
обсуждение не входит в наши планы.

А как следствие, ядро оперирует со своим собственным набором API (kernel
API), отличающимся от POSIX API (отличающихся набором функций, их
наименованиями). Это видно на примере идентичных по смыслу, но
различающихся вызовах printk() и printf(). И если мы и будем встречаться
довольно часто с **якобы идентичными** функциями (sprint(), strlen(),
strcat() и многие другие), то это только внешняя **видимость
совпадения**. Эти функции реализуют ту же функциональность, но это
**дубликатная** реализация: подобный код реализуется и размещается **в
разных местах**, для POSIX API в составе библиотек, а для модулей —
непосредственно в составе ядра.

Возьмём на заметку, что у этих двух эквивалентных реализаций будет и
различная авторская (если можно так сказать) принадлежность, и время
обновления. Реализация в составе библиотеки libc.so, изготавливается
сообществом GNU/FSF в комплексе проекта компилятора GCC, и новая версия
библиотеки (и её заголовочные файлы в /usr/include) устанавливаются,
когда вы обновляете версию **компилятора**. А реализация версии той же
функции в ядре по авторству принадлежит разработчикам ядра Linux, и
будет обновляться когда вы обновляете **ядро**, будь то из репозитария
используемого вами дистрибутива, или собирая его самостоятельно из
исходных кодов. А эти обновления (**компилятора и ядра**), как понятно,
являются не коррелированными и не синхронизированными. Это не очевидная
и часто опускаемая из виду особенность!

Косвенным следствием из сказанного будет то, что программный код
процесса и модуля в качестве каталогов для файлов определений (.h) по
умолчанию (\#include \<...\>) будут использовать совершенно разные
источники: /usr/lib/include и /lib/modules/\`uname -r\`/build/include,
соответственно. Но об этом мы поговорим подробно, когда будем детально
разбирать варианты сборки модулей.

Побочным следствием дублирования реализации подобных функций может
оказаться и то, что в некоторых деталях поведения будут различаться
идентичные по наименованию функции API ядра и API POSIX.

​2. Как следствие этой автономности реализации API ядра является то, что
одной из основных трудностей программирования модулей и является
**нахождение и выбор** адекватных средств API из набора плохо
документированных и достаточно часто изменяющихся API ядра. Если по
POSIX API существуют многочисленные обстоятельные справочники, то по
именам ядра (вызовам и структурам данных) таких руководств нет. А общая
размерность имён ядра (в /proc/kallsyms) приближается к 100000, из
которых до 10000 — это экспортируемые имена ядра.

Иногда очень помогает отслеживание аналогичных вызовов пространств
пользователя и ядра, примеры только некоторых из них собраны в табл.1.

Таблица 1: примеры вызовов API POSIX и ядра, несущих эквивалентную
функциональность.

API процессов (POSIX)

API ядра

strcpy(), strncpy(), strcat(), strncat(), strcmp (), strncmp(), strchr
(), strlen(), strnlen(), strstr(), strrchr()

strcpy (), strncpy (), strcat(), strncat(), strcmp(), strncmp(),
strchr(), strlen(), strnlen(), strstr(), strrchr()

printf()

printk()

execl(), execlp(), execle(), execv(), execvp(), execve()

call\_usermodehelper()

malloc(), calloc(), alloca()

kmalloc(), vmalloc()

kill(), sigqueue()

send\_sig()

open(), lseek(), read(), write(), close()

filp\_open(), kernel\_read(), kernel\_write(), vfs\_llseek(),
vfs\_read(), vfs\_write(), filp\_close()

atol(), sscanf()

simple\_strtoul(), sscanf()

pthread\_create()

kernel\_thread()

pthread\_mutex\_lock(), pthread\_mutex\_trylock(),
pthread\_mutex\_unlock()

rt\_mutex\_lock(), rt\_mutex\_trylock(), rt\_mutex\_unlock()

​3. Одна из основных трудностей программирования модулей состоит в
нахождении и выборе слабо документированных и изменяющихся API ядра. В
этом нам значительную помощь оказывает динамические и статические
таблицы разрешения имён ядра, и заголовочные файлы исходных кодов ядра,
по которым мы должны постоянно сверяться на предмет актуальности ядерных
API текущей версии используемого нами ядра.

По kernel API практически **отсутствует документация** и описания.
Выяснять детали функционирования придётся по заголовочным файлам
(хэдерам) и исходным кодам реализации (что особенно хлопотно). Некоторую
ясность может внести изучение прототипов использования требуемых API,
найденные контексным поиском в Интернет. Особое внимание следует
обратить на **комментарии** в хэдерах и исходном коде.

​4. Ещё одной особенностью kernel API является их высокая волатильность
от версии к версии ядра: вызов API, имеющий 3 параметра и успешно
работающий в текущей версии, может получить 4 параметра в следующей
версии, а код перестанет даже компилироваться. Это радикально отличает
программирование ядра от POSIX API, где вызовы регламентированы
стандартом, должны ему подчиняться и многократно описаны. Разработчики
ядра, в отличие от POSIX, не связаны никакими соглашениями о
совместимости сверху-вниз. Поэтому хороший код (модулей) ядра должен
содержать во множестве препроцессорные секции вида:

\#include \<linux/version.h\>

...

\#if (LINUX\_VERSION\_CODE \< KERNEL\_VERSION(2, 6, 24))

...

\#elif (LINUX\_VERSION\_CODE \< KERNEL\_VERSION(3, 17, 0))

...

\#else

...

\#endif

Вы не имеете права предполагать в какой версии ядра будет компилировать
ваш модуль его пользователь!

​5. **Уникальными ресурсами**, позволяющем изучить и сравнить исходный
код ядра для различных **версий** ядра и аппаратных **платформ**,
являются ресурсы построенные на базе проекта LXR, например, такие как
(даю несколько альтернатив, потому что каждая из них может в какое-то
время быть недоступной):

[http://lxr.free-electrons.com/source/](http://lxr.free-electrons.com/source/)
(Linux Cross Reference)

[http://lxr.linux.no/+trees](http://lxr.linux.no/+trees) (the Linux
Cross Reference)

[http://lxr.oss.org.cn/](http://lxr.oss.org.cn/) (Linux Kernel Cross
Reference)

[http://lxr.missinglinkelectronics.com/linux](http://lxr.missinglinkelectronics.com/linux)
(missing link elektronics)

Это основные источники (из известных автору), позволяющий сравнивать
изменения в API и реализациях от версии к версии (начиная с самых ранних
версий ядра). Часто изучение элементов кода ядра по этим ресурсам
гораздо продуктивнее, чем то же, но по исходному коду непосредственно
вашей инсталлированной системы. Вообще, как показывает практика, иметь в
своей локальной системе исходный код ядра Linux собственного варианта
(версия, платформа) и на него опираться при работе — порочная практика.

​6. Следующей особенностью есть то, что при отладке кода ядра даже
незначительная ошибка в коде может стать причиной полного краха ядра
(например, элементарный вызов strcpy() ). Вплоть до того (и это следует
ожидать), что в некоторых случаях система перед гибелью даже не успевает
дать предсмертное отладочное сообщение Ooops...

Отсутствие защиты памяти. Если обычная программа предпринимает попытку
некорректного обращения к памяти, ядро аварийно завершит процесс, послав
ему сигнал SIGSEGV. Если ядро предпримет попытку некорректного обращения
к памяти, результаты могут быть менее контролируемыми. К тому же ядро не
использует замещение страниц: каждый байт, используемый в ядре – это
один байт физической памяти.

​7. Как следствие высокой вероятности краха системы даже в итоге
незначительной ошибки кода является то, что **каждый** тестовый запуск
может требовать перезагрузки системы, а это **в разы** замедляет темп
проекта, в сравнении с ориентирами пользовательского пространства.

Отличным решением (по крайней мере, когда не требуется какая-то
аппаратная специфика) является решение вести разработку в среде
**виртуальной машины** Linux, на начальном этапе проекта и до до 90%
общего времени разработки. Для этого не очень пригодны развитые системы
виртуализации типа XEN и подобные, но очень подходят достаточно простые
гипервизоры Oracle VirtualBox, или QEMU и KVM (когда нужна архитектура
отличная от x86).

​8. Ещё один аспект применения виртуальных машин состоит в том, что
разрабатываемый модуль может (должен) быть «прогнан» через ядра
различных версий, для предоставления потребителю качественного
результата и отсутствия рекламаций (невозможно предсказать в каком ядре
потребитель станет собирать модуль). Провести такое тестирование на
реальных инсталляциях практически невозможно. А иметь в виртуальном
гипервизоре 10 различных виртуальных машин (и даже одновременно
выполняющихся) — совершенно реально.

​9. В ядре нельзя использовать вычисления с плавающей точкой.
Активизация режима вычислений с плавающей точкой требует (при
переключении контекста) сохранения и восстановления регистров устройства
поддержки вычислений с плавающей точкой (FPU), помимо других рутинных
операций. Вряд ли в модуле ядра могут понадобится вещественные
вычисления, но если такое и случится, то их нужно эмулировать через
целочисленные вычисления (для этого существует множество библиотек, из
которых может быть **заимствован** код).

​10. Фиксированный стек – область адресного пространства, в которой
выделяются локальные переменные. Локальные переменные – это все
переменные, объявленные внутри блока, открывающегося левой открывающей
фигурной скобкой и не имеющие ключевого слова static. Стек в режиме ядра
ограничен по размеру и не может быть изменён. Поэтому в коде ядра нужно
крайне осмотрительно использовать (или не использовать) конструкции,
расточающие пространство стека: рекурсию, передача параметром структуры,
или возвращаемое значение из функции как структура, объявление крупных
локальных структур внутри функций и подобных им. Обычно стек равен двум
страницам памяти, что соответствует, например, 8 Кбайт для 32-бит систем
и 16 Кбайт для 64-бит систем.

Создание среды разработки
-------------------------

Первично установленная по умолчанию из пакетного дистрибутива система
Linux для сборки ядра модулей ядра **непригодна**. В ней отсутствуют
некоторые специфические компоненты, такие как хэдеры ядра и другие
подобные. Это и естественно, так как рядовому пользователю нет нужды
собирать модули ядра, и незачем ему загружать файловую систему
достаточно объёмными бесполезными данными. Но вам необходимо создать
среду сборки, если вы не сделали этого ранее. Для этого нужно установить
некоторые дополнительные пакеты из репозитария...

Начиная с того, что зачастую (во многих дистрибутивах) и сам компилятор
GCC и утилита make могут отсутствовать в системе при дефаултной
установке, что мы проверим так:

**\$ which gcc**

**\$ which make**

**\$**

Нужно начать с установки этих основных средств программирования. Вот как
это выглядит в дистрибутиве Debian (Ubuntu) Linux (и то, что пакеты
потянут за собой по зависимостям):

**\# apt-get install gcc make**

Чтение списков пакетов… Готово

Построение дерева зависимостей

Чтение информации о состоянии… Готово

Будут установлены следующие дополнительные пакеты:

binfmt-support binutils cpp-4.6 g++-4.6 gcc-4.6 gcc-4.6-base gcc-4.7
libc-dev-bin libc6-dev

libffi-dev libitm1 libllvm3.0 libstdc++6-4.6-dev linux-libc-dev

Предлагаемые пакеты:

binutils-doc gcc-4.6-locales g++-4.6-multilib gcc-4.6-doc
libstdc++6-4.6-dbg gcc-multilib

autoconf automake1.9 libtool flex bison gdb gcc-doc gcc-4.6-multilib
libmudflap0-4.6-dev

libgcc1-dbg libgomp1-dbg libquadmath0-dbg libmudflap0-dbg binutils-gold
gcc-4.7-multilib

libmudflap0-4.7-dev gcc-4.7-doc gcc-4.7-locales libitm1-dbg
libcloog-ppl0 libppl-c2 libppl7

glibc-doc libstdc++6-4.6-doc

...

**\$ gcc --version**

gcc (Debian 4.7.2-5) 4.7.2

...

**\$ make --version**

GNU Make 3.81

...

\
\

В RPM-дистрибутивах (Fedora, CentOS, RedHat, ...) установка этих же
инструментов сборки делается командой:

**\# yum install gcc make**

...

\
\

Но сделанного нами мало — этого достаточно для прикладного
программирования, но недостаточно для программирования модулей ядра. Нам
нужно создать инфраструктуру для сборки модулей ядра (главным образом
это заголовочные файлы ядра, но не только).

В Fedora, CentOS, RedHat, ... нам необходимы дополнительные пакеты
kernel-headers.\* (обычно устанавливается вместе с ядром) и
kernel-devel.\* :

**\$ yum list all kernel\***

...

0 packages excluded due to repository protections

Установленные пакеты

kernel.i686 3.12.7-300.fc20 @fedora-updates/\$releasever

kernel.i686 3.12.10-300.fc20 @updates

kernel-headers.i686 3.12.10-300.fc20 @updates

kernel-modules-extra.i686 3.12.7-300.fc20 @fedora-updates/\$releasever

kernel-modules-extra.i686 3.12.10-300.fc20 @updates

Доступные пакеты

kernel.i686 3.13.6-200.fc20 updates

...

kernel-devel.i686 3.13.6-200.fc20 updates

...

kernel-headers.i686 3.13.6-200.fc20 updates

kernel-modules-extra.i686 3.13.6-200.fc20 updates

...

Обращаем внимание на то, что пакет kernel-devel.\* предоставляется в
репозитариях только для последнего обновляемого ядра (а не для
предыдущих установленных), то есть целесообразно начать с обновления
ядра:

**\$ sudo yum update kernel\***

...

**\$ sudo yum install kernel-devel.i686**

...

Объем загрузки: 8.5 M

Объем изменений: 31 M

Is this ok [y/d/N]: y

...

Вот только после этого у вас создастся инфраструктура, **для текущей
версии ядра**, для работы с модулями:

**\$ ls /usr/lib/modules**

3.12.10-300.fc20.i686 3.12.7-300.fc20.i686 3.13.6-200.fc20.i686

**\$ tree -L 2 /usr/src/kernels/**

/usr/src/kernels/

└── 3.13.6-200.fc20.i686

├── arch

├── block

├── crypto

├── drivers

├── firmware

├── fs

├── include

├── init

├── ipc

├── Kconfig

├── kernel

├── lib

├── Makefile

├── mm

├── Module.symvers

├── net

├── samples

├── scripts

├── security

├── sound

├── System.map

├── tools

├── usr

├── virt

└── vmlinux.id

\
\

21 directories, 5 files

В дистрибутивах Debian/Ubuntu картина, в общем, та же, только здесь вам
необходима установка только одного пакета (linux-headers-\* - выбранного
**для вашей архитектуры ядра**) :

**\$ cat /etc/debian\_version**

7.2

**\$ aptitude show linux-headers**

Нет в наличии или подходящей версии для linux-headers

Пакет: linux-headers

Состояние: не реальный пакет

Предоставляется: linux-headers-3.2.0-4-486,
linux-headers-3.2.0-4-686-pae,

linux-headers-3.2.0-4-amd64, linux-headers-3.2.0-4-rt-686-pae,
linux-headers-486,

linux-headers-686-pae, linux-headers-amd64, linux-headers-rt-686-pae

...

**\$ sudo aptitude install linux-headers-3.2.0-4-486**

...

Настраивается пакет linux-headers-3.2.0-4-486 (3.2.51-1) …

**\$ ls /lib/modules/3.2.0-4-486 -l**

итого 3000

lrwxrwxrwx 1 root root 34 Сен 20 17:26 build -\>
/usr/src/linux-headers-3.2.0-4-486

drwxr-xr-x 9 root root 4096 Окт 13 19:38 kernel

-rw-r--r-- 1 root root 723786 Окт 13 19:51 modules.alias

-rw-r--r-- 1 root root 705194 Окт 13 19:51 modules.alias.bin

-rw-r--r-- 1 root root 2954 Сен 20 17:26 modules.builtin

-rw-r--r-- 1 root root 3960 Окт 13 19:51 modules.builtin.bin

-rw-r--r-- 1 root root 353853 Окт 13 19:51 modules.dep

-rw-r--r-- 1 root root 491462 Окт 13 19:51 modules.dep.bin

-rw-r--r-- 1 root root 325 Окт 13 19:51 modules.devname

-rw-r--r-- 1 root root 118244 Сен 20 17:26 modules.order

-rw-r--r-- 1 root root 131 Окт 13 19:51 modules.softdep

-rw-r--r-- 1 root root 286536 Окт 13 19:51 modules.symbols

-rw-r--r-- 1 root root 364265 Окт 13 19:51 modules.symbols.bin

lrwxrwxrwx 1 root root 37 Сен 20 17:26 source -\>
/usr/src/linux-headers-3.2.0-4-common

\
\

Во всех случаях смысл состоит в том, чтобы добиться, чтобы путь для
текущего ядра /lib/modules/\`uname -r\`/build представлял не **пустую
висящую ссылку**, а был иерархией заполненных каталогов для сборки
модулей:

**\$ ls -d -w 100 /lib/modules/\`uname -r\`/build/\***

/lib/modules/3.13.6-200.fc20.i686/build/arch

/lib/modules/3.13.6-200.fc20.i686/build/block

/lib/modules/3.13.6-200.fc20.i686/build/crypto

/lib/modules/3.13.6-200.fc20.i686/build/drivers

/lib/modules/3.13.6-200.fc20.i686/build/firmware

/lib/modules/3.13.6-200.fc20.i686/build/fs

/lib/modules/3.13.6-200.fc20.i686/build/include

/lib/modules/3.13.6-200.fc20.i686/build/init

/lib/modules/3.13.6-200.fc20.i686/build/ipc

/lib/modules/3.13.6-200.fc20.i686/build/Kconfig

/lib/modules/3.13.6-200.fc20.i686/build/kernel

/lib/modules/3.13.6-200.fc20.i686/build/lib

/lib/modules/3.13.6-200.fc20.i686/build/Makefile

/lib/modules/3.13.6-200.fc20.i686/build/mm

/lib/modules/3.13.6-200.fc20.i686/build/Module.symvers

/lib/modules/3.13.6-200.fc20.i686/build/net

/lib/modules/3.13.6-200.fc20.i686/build/samples

/lib/modules/3.13.6-200.fc20.i686/build/scripts

/lib/modules/3.13.6-200.fc20.i686/build/security

/lib/modules/3.13.6-200.fc20.i686/build/sound

/lib/modules/3.13.6-200.fc20.i686/build/System.map

/lib/modules/3.13.6-200.fc20.i686/build/tools

/lib/modules/3.13.6-200.fc20.i686/build/usr

/lib/modules/3.13.6-200.fc20.i686/build/virt

/lib/modules/3.13.6-200.fc20.i686/build/vmlinux.id

\
\

Задачи
------

1.  Найдите и выпишите **как можно больше** (оцениваем по числу
    существенных позиций) отличий в программировании приложений
    пользователя и модулей ядра. В тексте названы далеко не все
    различия, который могут «выплыть» в программировании модулей ядра.
    Вернитесь к этому вопросу после проработки всего материала.

2.  Проверьте в своей системе (и, возможно, архитектуре) сборку и
    загрузку простейшего модуля ядра (любого из приводимых в архиве
    примеров). Это необходимо для работы со всем последующим материалом.
